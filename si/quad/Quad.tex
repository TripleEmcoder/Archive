\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}
\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Implementacja gry ,,Quad''}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Sztuczna inteligencja \\ Implementacja gry ,,Quad''}
\author{Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\section{Opis gry}
Gra ,,Quad'' jest gr¹ dwuosobow¹ rozgrywan¹ na planszy o rozmiarach 8x8. Ka¿dy z graczy dysponuje 12-25 pionkami swojego koloru - liczbê tê ustala siê przed rozpoczêciem rozgrywki. Celem gry jest u³o¿enie 4 swoich pionków w linii prostej (poziomo lub pionowo). Aby tego dokonaæ gracze naprzemian wykonuj¹ jeden z ruchów:
\begin{itemize}
\item ustawienie nowego pionka na planszy (jeœli gracz jeszcze nimi dysponuje),
\item przestawienie w³asnego pionka na s¹siednie, wolne pole (jeœli wszystkie pionki zosta³y ju¿ ustawione).
\end{itemize}
Poprzez przestawienie pionka mo¿na zbiæ pionek przeciwnika. Dzieje siê tak wtedy, gdy w wyniku tego przestawienia pionek przeciwnika zostanie otoczony przynajmniej dwoma pionkami gracza. Je¿eli w wyniku zbijania przeciwnik straci wszystkie pionki, gracz równie¿ wygrywa.

Implementacja gry umo¿liwia w pe³ni dowolny wybór rozmiaru planszy i iloœci pionków. Pionki dwóch graczy s¹ odpowiednio bia³e lub czarne.

\section{Opis implementacji}
\subsection{Reprezentacja stanu gry}
Plansza gry reprezentowana jest jako dwuwymiarowa tablica o odpowiednich rozmiarach, przechowuj¹ca obiekty typu wyliczeniowego: brak pionka, pionek bia³y, pionek czarny. Podczas rysowania planszy na ekranie obiekty te zamieniane s¹ na odpowiednie obrazki.

\subsection{Generowanie ruchów dopuszczalnych}
Ruchy w grze reprezentowane s¹ zawsze przez trójkê: kolor gracza, pole Ÿród³owe, pole docelowe. Pozwala to reprezentowaæ zarówno ruchy polegaj¹ce przestawieniu pionka jak i ustawieniu pionka (pole Ÿród³owe równe null) i zbiciu pionka (pole docelowe równe null). Dla ka¿dego wykonywanego ruchy tworzony jest nowy obiekt, zawieraj¹cy kolekcjê: wykonywany ruch, konsekwencje ruchu. Konsekwencje ruchu pojawiaj¹ siê w momencie, gdy mamy do czynienia ze zbijaniem pionków.

Generowanie nastêpników polega na przejrzeniu wszystkich pól i okreœleniu dla ka¿dego z nich mo¿liwych ruchów z jego udzia³em w nastêpuj¹cy sposób:
\begin{itemize}
\item jeœli dane pole jest puste i graczowi aktualnie wykonuj¹cemu ruch pozosta³y pionki do ustawienia to mo¿liwy ruch polega na ustawieniu w tym miejscu pionka,
\item jeœli dane pole jest zajête przez pionek gracza aktualnie wykonuj¹cego ruch i nie ma on wiêcej pionków do ustawienia, mo¿liwe ruchy polegaj¹ na przestawieniu pionka z tego pola na s¹siednie, wolne pole (przy czym kolejnoœæ poszukiwañ jest zawsze nastêpuj¹ca: pó³noc, po³udnie, wschód, zachód).
\end{itemize}

Lista nastêpników jest mieszana, aby zmniejszyæ przewidywalnoœæ ruchów komputera. Nastêpnie lista jest porz¹dkowana w taki sposób, aby na jej pocz¹tku znalaz³y siê (i by³y przegl¹dane w pierwszej kolejnoœci) ruchy rozgrywaj¹ce siê w centrum planszy. Prowadzi to do zwiêkszenia wydajnoœci programu, jako ¿e ruchy te s¹ najczêœciej o wiele lepsze od pozosta³ych, a co za tym idzie pozwalaj¹ na czêstsze odciêcia.

\subsection{Algorytny przeszukiwania przestrzeni stanów}
W programie zaimplementowano kilka algorytmów graj¹cych i ich wariantów:
\begin{enumerate}
\item \emph{NegMax} -- najprosztszy algorytm minimaksowy, zaimplementowany w celach testowych i porównawczych,

\item \emph{AlfaBeta} -- wykorzystuj¹cy odciêcia alfa i beta podczas przeszukiwania przestrzeni stanów,

\item \emph{AlfaBeta}, wariant \emph{FailSoft} -- wariant algorytmu AlfaBeta, który mo¿e zwracaæ rozwi¹zanie spoza przedzia³u $(alfa, beta)$, wykorzystywany do obliczania górnych i dolnych ograniczeñ oceny najlepszego ruchu,

\item \emph{AlfaBeta}, wariant \emph{FailSoft} + \emph{TranspositionTable} -- algorytm sterowania kolejnoœci¹ nastêpników, wykorzystuj¹cy dodatkowo tablicê przejœæ do pamiêtania stanów ju¿ odwiedzonych i odpowiadaj¹cych im najlepszych ruchów. Kluczem w tablicy jest tekstowa reprezentacja planszy -- ci¹g znaków odpowiadaj¹cych kolorom pionków (lub brakowi pionka) wraz z nazw¹ gracza aktualnie wykonuj¹cego ruch, odpowiada mu zestaw danych: najlepszy ruch, wartoœæ oceny dla tego ruchu, rodzaj ograniczenia (górne, dolne lub dok³adne) i g³êbokoœæ przeszukiwania. Tablica wykorzystuje standardow¹ kolekcjê System.Collections.Hashtable oraz standardow¹ funkcjê haszuj¹c¹ klasy string. Dziêki zastosowaniu iteracyjnego pog³êbiania i tablicy przejœæ najlepszy ruch jest sprawdzany jako pierwszy w ka¿dym wierzcho³ku. 

\item \emph{NegaScout} -- algorytm sterowania zakresem alfa i beta, wykorzystuj¹cy porz¹dkowanie nastêpników w oparciu o informacje z tablicy przejœæ. Najpierw przeszukiwany jest nastêpnik odpowiadaj¹cy najlepszemu znanemu ruchowi, a nastêpnie kolejne -- ze zredukowanym zakresem alfa i beta. Algorytm wykorzystuje tak¹ sam¹ tablicê przejœæ jak algorytm \emph{AlfaBeta}.

\end{enumerate}

\subsection{Funkcja oceny heurystycznej stanu}
Funkcja oceny jest oparta na s¹siedztwie pionków i wynika wprost celu gry jakim jest u³o¿enie linii 4 pionków. Funkcja premiuje pionki na planszy, które potencjalnie mog¹ s³u¿yæ do u³o¿enia linii, wysokoœæ premii zale¿y od iloœci pionków brakuj¹cych do u³o¿enia wygrywaj¹cej kombinacji. Takie podejœcie w sposób naturalny preferuje zajmowanie pól w pobli¿u œrodka planszy, poniewa¿ daj¹ wiêksze szanse na u³o¿enie czwórki.

Dodatkowo funkcja uwzglêdnia gracza aktualnie wykonuj¹cego ruch. Specyfika gry wymaga, aby gracz rozpoczynaj¹cy (gracz czarny) gra³ bardziej ofensywnie (próbowa³ u³o¿yæ liniê), a gracz graj¹cy jako drugi (gracz bia³y) powinien graæ bardziej defensywnie (uniemo¿liwiaæ przeciwnikowi u³o¿enie linii). Zatem gracz gracz czarny za uk³ad potencjalnie stwarzaj¹cy mo¿liwoœæ u³o¿enia linii otrzymuje wiêksz¹ premiê ni¿ gracz bia³y. Podobnie gracz bia³y otrzymuje wiêksze premie za utrudnianie gry przeciwnikowi.

Funkcja zwraca wartoœci z przedzia³u $[-10000,10000]$. Wysokoœci premii zosta³y wyznaczone poprzez porównywanie wyników gier pomiêdzy graczami wykorzystuj¹cymi funkcje oceny o ró¿nych wagach. Funkcja ma liniow¹ z³o¿onoœæ obliczeniow¹ wzglêdem iloœci pól na planszy.

jaki typ funkcji: zliczeniowa (bilans ró¿nicowy, ilorazowy), po³o¿eniowa (preferencja pewnych pól), odleg³oœciowa (jakie miary odleg³oœci i od/do czego je wyznaczamy), oparta na s¹siedztwie/otoczeniu, probabilistyczna, inna?
jaki przedzia³ wartoœci zwraca funkcja
jakie s¹ wartoœci skrajne (dla sukcesu, pora¿ki)
jak zosta³y wyznaczone wartoœci wag (o ile s¹ stosowane) poszczególnych sk³adowych funkcji
wady i zalety (jakie taktyczno-startegiczne cele gry uwzglêdnia a jakie ewentualnie nie s¹ brane pod uwagê)
przyk³ad stanu gry i ewaluacja wartoœci funkcji heurystycznej tego stanu z uwzglêdnieniem wartoœci poœrednich (wszystkich sk³adowych oceny ³¹cznej)

\section{Porównanie wydajnoœci algorytmów}
W celu zbadania wydajnoœci algorytmów przeprowadzono seriê testów z wykorzystaniem rozgrywek, w których obaj gracze byli sterowani komputerowo. W pary przeciwników po³¹czono algorytmy: \emph{AlfaBeta} i \emph{AlfaBeta} wariant {FailSafe} + \emph{TranspositionTable} oraz \emph{AlfaBeta} wariant {FailSafe} + \emph{TranspositionTable} i \emph{NegaScout}. Wyniki pomiarów przedstawiaj¹ nastêpuj¹ce tabele i wykresy.

\begin{table}
\centering
\begin{minipage}[t]{0.4\textwidth}
\begin{tabular}{|r|r|r|}
\hline
Tura & AlfaBeta & AlfaBetaFSTT \\
\hline
1 & 4257 & 4514 \\
2 & 7899 & 5960 \\
3 & 4148 & 4279 \\
4 & 4190 & 4433 \\
5 & 4959 & 5008 \\
6 & 4706 & 4264 \\
7 & 8769 & 5268 \\
8 & 8779 & 2923 \\
9 & 4368 & 3871 \\
10 & 6183 & 4144 \\
11 & 8866 & 6600 \\
12 & 15399 & 2922 \\
13 & 6182 & 4761 \\
14 & 9086 & 3505 \\
15 & 5612 & 3223 \\
16 & 4073 & 2742 \\
17 & 4806 & 4069 \\
18 & 3230 & 2651 \\
19 & 5128 & 3456 \\
20 & 4662 & 3827 \\
21 & 7670 & 3433 \\
22 & 6900 & 5136 \\
23 & 3170 & 2869 \\
24 & 1385 & 1339 \\
25 & 278 & 321 \\
26 & 449 & 156 \\
27 & 264 & 294 \\
\hline
\end{tabular}
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{tabular}{|r|r|r|}
\hline
Tura & AlfaBeta & AlfaBetaFSTT \\
\hline
1 & 16029 & 17476 \\
2 & 28350 & 27658 \\
3 & 38474 & 23911 \\
4 & 21683 & 22427 \\
5 & 37584 & 24851 \\
6 & 21010 & 21856 \\
7 & 26432 & 16787 \\
8 & 14012 & 12066 \\
9 & 16889 & 13704 \\
10 & 29551 & 26289 \\
11 & 34877 & 5165 \\
12 & 18651 & 22934 \\
13 & 27310 & 11216 \\
14 & 90092 & 8683 \\
15 & 27901 & 22243 \\
16 & 30744 & 16626 \\
17 & 12971 & 7985 \\
18 & 22825 & 18835 \\
19 & 10268 & 45674 \\
20 & 12662 & 9301 \\
21 & 50244 & 8129 \\
22 & 67998 & 1768 \\
23 & 20019 & 15978 \\
24 & 11178 & 5849 \\
25 & 7610 & 2197 \\
26 & 1634 & 1080 \\
27 & 3191 & 2046 \\
28 & 6836 & 4154 \\
29 & 7120 & 2210 \\
30 & 14323 & 3995 \\
31 & 23838 & 16881 \\
32 & 9298 & 1593 \\
33 & 11120 & 555 \\
34 & 6577 & 1163 \\
\hline
\end{tabular}
\end{minipage}

\caption{Liczba przeszukiwanych wierzcho³ków w kolejnych turach gry algorytmów \emph{AlfaBeta} i \emph{AlfaBeta} wariant \emph{FailSafe} + \emph{TranspositionTable} przy g³êbokoœci 3 i 4}
\end{table}


\begin{table}
\centering

\begin{minipage}[t]{0.4\textwidth}
\begin{tabular}{|r|r|r|}
\hline
Tura & AlfaBetaFSTT & NegaScout \\
\hline
1 & 4514 & 4515 \\
2 & 5960 & 4753 \\
3 & 4279 & 4224 \\
4 & 4433 & 4547 \\
5 & 5008 & 4160 \\
6 & 4264 & 4442 \\
7 & 5268 & 4660 \\
8 & 2923 & 2932 \\
9 & 3871 & 3734 \\
10 & 4144 & 3832 \\
11 & 6600 & 5977 \\
12 & 2922 & 2921 \\
13 & 4761 & 4182 \\
14 & 3505 & 3430 \\
15 & 3223 & 3039 \\
16 & 2742 & 2743 \\
17 & 4069 & 3018 \\
18 & 2651 & 2571 \\
19 & 3456 & 2694 \\
20 & 3827 & 3082 \\
21 & 3433 & 3134 \\
22 & 5136 & 3526 \\
23 & 2869 & 2621 \\
24 & 1339 & 1192 \\
25 & 321 & 333 \\
26 & 156 & 156 \\
27 & 294 & 294 \\
\hline
\end{tabular}
\end{minipage}
\hfill
\begin{minipage}[t]{0.4\textwidth}
\begin{tabular}{|r|r|r|}
\hline
Tura & AlfaBetaFSTT & NegaScout \\
\hline
1 & 17476 & 16269 \\
2 & 27658 & 26104 \\
3 & 23911 & 19810 \\
4 & 22427 & 22921 \\
5 & 24851 & 24172 \\
6 & 21856 & 21827 \\
7 & 16787 & 17109 \\
8 & 12066 & 11465 \\
9 & 13704 & 11459 \\
10 & 26289 & 26800 \\
11 & 5165 & 6579 \\
12 & 22934 & 24688 \\
13 & 11216 & 10466 \\
14 & 8683 & 6172 \\
15 & 22243 & 21156 \\
16 & 16626 & 17584 \\
17 & 7985 & 6735 \\
18 & 18835 & 17039 \\
19 & 45674 & 36308 \\
20 & 9301 & 8372 \\
21 & 8129 & 7733 \\
22 & 1768 & 1827 \\
23 & 15978 & 15263 \\
24 & 5849 & 5304 \\
25 & 2197 & 2010 \\
26 & 1080 & 1050 \\
27 & 2046 & 1765 \\
28 & 4154 & 4119 \\
29 & 2210 & 1962 \\
30 & 3995 & 3117 \\
31 & 16881 & 11731 \\
32 & 2150 & 2152 \\
33 & 555 & 594 \\
34 & 1244 & 1149 \\
\hline
\end{tabular}
\end{minipage}

\caption{Liczba przeszukiwanych wierzcho³ków w kolejnych turach gry algorytmów \emph{AlfaBeta} wariant \emph{FailSafe} + \emph{TranspositionTable} i \emph{NegaScout} przy g³êbokoœci 3 i 4}
\end{table}

\section{Wnioski, uwagi i podsumowanie}
Szacunkowy rozmiar przestrzeni stanów wynosi $3^64$. Rozmiar grafu wynosi oko³o $64^{g³êbokoœæ}$ i nieznacznie maleje wraz z rozwojem rozgrywki. Znacz¹cy spadek rozmiaru grafu obserwuje siê dopiero na kilka ruchów przed zakoñczeniem rozgrywki, po zakoñczeniu fazy ustawiania pionków. 

W³aœnie ze wzglêdu na bardzo du¿y pocz¹tkowy rozmiar grafu niemo¿liwe by³o w rozs¹dnym czasie uzyskanie g³êbokoœci przeszukiwania wiêkszej ni¿ 4, pomimo zastosowania doœæ wyszukanych algorytmów. Najlepsze efekty, zgodnie z przewidywaniami, da³ algorytm \emph{NegaScout} w po³¹czeniu z tablic¹ przejœæ. 

Du¿¹ trudnoœci¹ okaza³o siê stworzenie dobrej funkcji oceny. Dobre efekty da³o zró¿nicowanie oceny w zale¿noœci od gracza wykonuj¹cego ruch. Mo¿liwe by³oby dalsze jej dopracowanie np. poprzez zastosowanie algorytmu genetycznego do wyznaczenia najlepszych wag.

Koñcowy efekt jest doœæ dobry, cz³owiekowi trudno wygraæ z komputerem. W pojedynku innym programem (\emph{Zillions of Games}) nasz program z ³atwoœci¹ wygrywa je¿eli zaczyna pojedynek, je¿eli gra jako drugi czasem wygrywa, czasem przegrywa.

\end{document}
