\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}
\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Implementacja gry ,,Quad''}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Sztuczna inteligencja \\ Implementacja gry ,,Quad''}
\author{ Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\section{Opis gry}
Gra ,,Quad'' jest gr¹ dwuosobow¹ rozgrywan¹ na planszy o rozmiarach 8x8. Ka¿dy z graczy dysponuje 12-25 pionkami swojego koloru - liczbê tê ustala siê przed rozpoczêciem rozgrywki. Celem gry jest u³o¿enie 4 swoich pionków w linii prostej (poziomo lub pionowo). Aby tego dokonaæ gracze naprzemian wykonuj¹ jeden z ruchów:
\begin{enumerate}
\item ustawienie nowego pionka na planszy (jeœli gracz jeszcze nimi dysponuje),
\item przestawienie w³asnego pionka na s¹siednie, wolne pole (jeœli wszystkie pionki zosta³y ju¿ ustawione).
\end{enumerate}
Poprzez przestawienie pionka mo¿na zbiæ pionek przeciwnika. Dzieje siê tak wtedy, gdy w wyniku tego przestawienia pionek przeciwnika zostanie otoczony przynajmniej dwoma pionkami gracza. Je¿eli w wyniku zbijania przeciwnik straci wszystkie pionki, gracz równie¿ wygrywa.

Implementacja gry umo¿liwia w pe³ni dowolny wybór rozmiaru planszy i iloœci pionków. Pionki dwóch graczy s¹ odpowiednio bia³e lub czarne.

\section{Implementacja}
\subsection{Reprezentacja stanu gry}
Plansza gry reprezentowana jest jako dwuwymiarowa tablica o odpowiednich rozmiarach, przechowuj¹ca obiekty typu wyliczeniowego: brak pionka, pionek bia³y, pionek czarny. Podczas rysowania planszy na ekranie obiekty te zamienianê s¹ na odpowiednie obrazki.

??? przyk³ad planszy i jej reprezentacja w pamiêci ???

\subsection{Generowanie ruchów dopuszczalnych}
Ruchy w grze reprezentowane s¹ zawsze przez trójkê: kolor gracza, pole Ÿród³owe, pole docelowe. Pozwala to reprezentowaæ zarówno ruchy polegaj¹ce przestawieniu pionka jak i ustawieniu pionka (pole Ÿród³owe równe null) i zbiciu pionka (pole docelowe równe null). Dla ka¿dego wykonywanego ruchy tworzony jest nowy obiekt, zawieraj¹cy kolekcjê: wykonywany ruch, konsekwencje ruchu. Konsekwencje ruchu pojawiaj¹ siê w momencie, gdy mamy do czynienia ze zbijaniem pionków.

Generowanie nastêpników polega na przejrzeniu wszystkich pól i okreœleniu dla ka¿dego z nich mo¿liwych ruchów z jego udzia³em w nastêpuj¹cy sposób:
\begin{enumerate}
\item jeœli dane pole jest puste i graczowi aktualnie wykonuj¹cemu ruch pozosta³y pionki do ustawienia to mo¿liwy ruch polega na ustawieniu w tym miejscu pionka,
\item jeœli dane pole jest zajête przez pionek gracza aktualnie wykonuj¹cego ruch i nie ma on wiêcej pionków do ustawienia, mo¿liwe ruchy polegaj¹ na przestawieniu pionka z tego pola na s¹siednie, wolne pole (przy czym kolejnoœæ poszukiwañ jest zawsze nastêpuj¹ca: pó³noc, po³udnie, wschód, zachód).
\end{enumerate}

??? niedeterminizm mechanizmu generacji nastêpników (dodatkowa iteracja "mieszaj¹ca" ruchy)
przyk³ady ruchów i ich realizacja programowa ???

\subsection{Metody przeszukiwania przestrzeni stanów gry - algorytmy graj¹ce}
Opis zastosowanych technik przeszukiwania z uwzglêdnieniem parametrów charakterystycznych dla danej metody.
Metody porz¹dkowania nastêpników z pamiêci¹
iteracyjne pog³ebianie: czy sortowanie nastepników tylko w korzeniu, czy w ka¿dym wêŸle grafu? jak i gdzie pamiêtane s¹ nastêpniki? czy jest (i jakie?) dodatkowe kryterium zatrzymania pog³êbiania poza max. g³êbokoœci¹ np.czas obliczeñ?
tablica przejœæ (transpozycji): jakie dane przechowywane s¹ w rekordzie tablicy przejœæ, czy pamiêtany jest bestmove? czy tablica odczytywana/zapisywana jest z/do pliku dyskowego na pocz¹tku/koñcu gry? jak i kiedy aktualizowana jest tablica, gdy wyst¹pi bicie (wiêkszoœæ wpisów jest ju¿ wtedy z regu³y nieaktualna!)
haszowanie: jaki klucz, jak jest generowany (z jakich danych ze stanu), jaki rozmiar tablicy haszowej, problem konfliktów? jak zosta³ rozwi¹zany- przez nadpisywanie czy listê konfliktow¹?
tablica historii ruchów: rozmiar tablicy, regu³a modyfikacji zapamiêtanej wartoœci/oceny ruchu, bezkontekstowa definicja ruchu czy kontekstowa? dla kontekstowej, jak zdefiniowany jest kontekst (czy jako np. s¹siedztwo)?
heurystyka "ruchów-zabójców": rozmiar tablicy (dla jakiej max. g³êbokoœci przeszukiwania)? czy pamiêtany jest jeden ruch na danym poziomie g³êbokoœci, czy mo¿e lista ruchów? dla listy ruchów na jednym poziomie: jak s¹ porz¹dkowane ruchy?
mechanizm ETC: pytania analogiczne jak przy tablicy transpozycji
Metody manipulowania zakresem alfa-beta
algorytm AspirationSearch: jak okreœlana jest wartoœæ pocz¹tkowa 'guess' i odchylenia 'delta'? czy zastosowano iteracyjne pog³êbianie, czy nie? po³¹czono je z porz¹dkowaniem nastêpników w korzeniu grafu, czy nie?
algorytm NegaScout(PVS): jak wybierany jest potencjalnie najlepszy potomek w ka¿dym wêŸle grafu? który mechanizm porz¹dkowania nastêpników spoœród opisanych wy¿ej zosta³ u¿yty? a mo¿e zastosowano inn¹ metodê selekcji ruchów? 
algorytm C*, MTD(f): jak ustalana jest wartoœæ pocz¹tkowa f ?  czy u¿yto tablicy transpozycji (opisanej wczeœniej)?
Metody sterowania g³êbokoœci¹ przeszukiwania
algorytm NullMoveSearch: jaka jest wartoœæ parametru R? jakie jest kryterium zatrzymania pog³êbieñ pog³êbieñ (tj. zagnie¿d¿onych "pustych ruchów")?
poszukiwanie stanów stabilnych: jakie ruchy s¹ pog³êbiane, o ile pog³êbiamy, jak i gdzie ustawione jest ograniczenie na górn¹ liczbê wielokrotnych naprzemiennych pog³êbieñ? czy w ogóle takie ograniczenie istnieje?

\subsection{Funkcja oceny heurystycznej stanu gry}
jaki typ funkcji: zliczeniowa (bilans ró¿nicowy, ilorazowy), po³o¿eniowa (preferencja pewnych pól), odleg³oœciowa (jakie miary odleg³oœci i od/do czego je wyznaczamy), oparta na s¹siedztwie/otoczeniu, probabilistyczna, inna?
jaki przedzia³ wartoœci zwraca funkcja
jakie s¹ wartoœci skrajne (dla sukcesu, pora¿ki)
jak zosta³y wyznaczone wartoœci wag (o ile s¹ stosowane) poszczególnych sk³adowych funkcji
wady i zalety (jakie taktyczno-startegiczne cele gry uwzglêdnia a jakie ewentualnie nie s¹ brane pod uwagê)
przyk³ad stanu gry i ewaluacja wartoœci funkcji heurystycznej tego stanu z uwzglêdnieniem wartoœci poœrednich (wszystkich sk³adowych oceny ³¹cznej)
\section{Testy wydajnoœci i porównania algorytmów}
Punktem odniesienia dla wszystkich stosowanych metod ma byæ "czysty" algorytm alfa-beta
Pomiary maj¹ dotyczyæ œredniej liczby odwiedzonych wierzcho³ków w grafie gry a NIE CZASÓW przeszukiwania
Porównania nale¿y przeprowadziæ dla co najmniej trzech ró¿nych stanów pocz¹tkowych (m.in. ró¿nych od stanu wynikaj¹cego z zasad rozpoczynania gry)
Porównania powinny byæ prowadzone dla kilku ró¿nych g³êbokoœci przeszukiwania
Testy nale¿y przeprowadziæ dla g³êbokoœci grafu wynosz¹cej co najmniej 5 niezale¿nie od tego czy wymaga to czasów obliczeñ rzêdu minuty, godziny, a mo¿e nawet doby - od czego w koñcu s¹ komputery ;-)
Je¿eli metoda charakteryzuje siê dodatkowymi parametrami (poza g³êbokoœci¹ przeszukiwania) nale¿y podaæ dla jakich wartoœci zosta³y przeprowadzone porównania
Wyniki porównañ powinny byæ przedstawione ZARÓWNO w postaci wykresów, jak i tabel
Ka¿da krzywa na wykresie powinna mieæ inny typ znacznika punktów pomiarowych tak, aby by³y czytelna na wydruku czarno-bia³ym niezale¿nie od faktycznie przypisanego jej koloru

\section{Wnioski, uwagi i podsumowanie}
Jaki jest szacunkowy rozmiar przestrzeni stanów zaimplementowanej gry? Jak zmienia siê rozmiar grafu w miarê postêpów gry? Roœnie, maleje, czy pozostaje raczej stabilny?
Która z zastosowanych metoda okaza³a siê najlepsza z punktu widzenia ograniczenia obszaru przeszukiwanej przestrzeni?
Czy ³atwo wygraæ cz³owiekowi (twórcy programu) z komputerem?
Czy wyst¹pi³ problem cykli w grafie gry i jak go rozwi¹zano? Czy og³aszany jest wtedy werdykt remisowy po pewnej sta³ej liczbie powtórzonych stanów?
Czy funkcja oceny okaza³a siê wystarczaj¹ca? Czy s¹ szanse na jest dalsz¹ poprawê? Je¿eli tak, to gdzie mo¿na by³oby wprowadziæ ulepszenia?
Czy by³y jakieœ trudne do wykrycia b³êdy implementacyjne?
Inne uwagi

\end{document}
