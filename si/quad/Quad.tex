\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}
\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Implementacja gry ,,Quad''}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Sztuczna inteligencja \\ Implementacja gry ,,Quad''}
\author{Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\section{Opis gry}
Gra ,,Quad'' jest gr¹ dwuosobow¹ rozgrywan¹ na planszy o rozmiarach 8x8. Ka¿dy z graczy dysponuje 12-25 pionkami swojego koloru - liczbê tê ustala siê przed rozpoczêciem rozgrywki. Celem gry jest u³o¿enie 4 swoich pionków w linii prostej (poziomo lub pionowo). Aby tego dokonaæ gracze naprzemian wykonuj¹ jeden z ruchów:
\begin{enumerate}
\item ustawienie nowego pionka na planszy (jeœli gracz jeszcze nimi dysponuje),
\item przestawienie w³asnego pionka na s¹siednie, wolne pole (jeœli wszystkie pionki zosta³y ju¿ ustawione).
\end{enumerate}
Poprzez przestawienie pionka mo¿na zbiæ pionek przeciwnika. Dzieje siê tak wtedy, gdy w wyniku tego przestawienia pionek przeciwnika zostanie otoczony przynajmniej dwoma pionkami gracza. Je¿eli w wyniku zbijania przeciwnik straci wszystkie pionki, gracz równie¿ wygrywa.

Implementacja gry umo¿liwia w pe³ni dowolny wybór rozmiaru planszy i iloœci pionków. Pionki dwóch graczy s¹ odpowiednio bia³e lub czarne.

\section{Opis implementacji}
\subsection{Reprezentacja stanu gry}
Plansza gry reprezentowana jest jako dwuwymiarowa tablica o odpowiednich rozmiarach, przechowuj¹ca obiekty typu wyliczeniowego: brak pionka, pionek bia³y, pionek czarny. Podczas rysowania planszy na ekranie obiekty te zamieniane s¹ na odpowiednie obrazki.

\subsection{Generowanie ruchów dopuszczalnych}
Ruchy w grze reprezentowane s¹ zawsze przez trójkê: kolor gracza, pole Ÿród³owe, pole docelowe. Pozwala to reprezentowaæ zarówno ruchy polegaj¹ce przestawieniu pionka jak i ustawieniu pionka (pole Ÿród³owe równe null) i zbiciu pionka (pole docelowe równe null). Dla ka¿dego wykonywanego ruchy tworzony jest nowy obiekt, zawieraj¹cy kolekcjê: wykonywany ruch, konsekwencje ruchu. Konsekwencje ruchu pojawiaj¹ siê w momencie, gdy mamy do czynienia ze zbijaniem pionków.

Generowanie nastêpników polega na przejrzeniu wszystkich pól i okreœleniu dla ka¿dego z nich mo¿liwych ruchów z jego udzia³em w nastêpuj¹cy sposób:
\begin{enumerate}
\item jeœli dane pole jest puste i graczowi aktualnie wykonuj¹cemu ruch pozosta³y pionki do ustawienia to mo¿liwy ruch polega na ustawieniu w tym miejscu pionka,
\item jeœli dane pole jest zajête przez pionek gracza aktualnie wykonuj¹cego ruch i nie ma on wiêcej pionków do ustawienia, mo¿liwe ruchy polegaj¹ na przestawieniu pionka z tego pola na s¹siednie, wolne pole (przy czym kolejnoœæ poszukiwañ jest zawsze nastêpuj¹ca: pó³noc, po³udnie, wschód, zachód).
\end{enumerate}

Lista nastêpników jest mieszana, aby zmniejszyæ przewidywalnoœæ ruchów komputera. Nastêpnie lista jest porz¹dkowana w taki sposób, aby na jej pocz¹tku znalaz³y siê (i by³y przegl¹dane w pierwszej kolejnoœci) ruchy rozgrywaj¹ce siê w centrum planszy. Prowadzi to do zwiêkszenia wydajnoœci programu, jako ¿e ruchy te s¹ najczêœciej o wiele lepsze od pozosta³ych, a co za tym idzie pozwalaj¹ na czêstsze odciêcia.

\subsection{Algorytny przeszukiwania przestrzeni stanów}
W programie zaimplementowano kilka algorytmów graj¹cych i ich wariantów:
\begin{enumerate}
\item \emph{NegMax} -- najprosztszy algorytm minimaksowy, zaimplementowany w celach testowych i porównawczych,

\item \emph{AlfaBeta} -- wykorzystuj¹cy odciêcia alfa i beta podczas przeszukiwania przestrzeni stanów,

\item \emph{AlfaBeta}, wariant \emph{FailSoft} -- wariant algorytmu AlfaBeta, który mo¿e zwracaæ rozwi¹zanie spoza przedzia³u $(alfa, beta)$, wykorzystywany do obliczania górnych i dolnych ograniczeñ oceny najlepszego ruchu,

\item \emph{AlfaBeta}, wariant \emph{FailSoft} + \emph{TranspositionTable} -- algorytm sterowania kolejnoœci¹ nastêpników, wykorzystuj¹cy dodatkowo tablicê przejœæ do pamiêtania stanów ju¿ odwiedzonych i odpowiadaj¹cych im najlepszych ruchów. Kluczem w tablicy jest tekstowa reprezentacja planszy -- ci¹g znaków odpowiadaj¹cych kolorom pionków (lub brakowi pionka) wraz z nazw¹ gracza aktualnie wykonuj¹cego ruch, odpowiada mu zestaw danych: najlepszy ruch, wartoœæ oceny dla tego ruchu, rodzaj ograniczenia (górne, dolne lub dok³adne) i g³êbokoœæ przeszukiwania. Tablica wykorzystuje standardow¹ kolekcjê System.Collections.Hashtable oraz standardow¹ funkcjê haszuj¹c¹ klasy string. Dziêki zastosowaniu iteracyjnego pog³êbiania i tablicy przejœæ najlepszy ruch jest sprawdzany jako pierwszy w ka¿dym wierzcho³ku. 

\item \emph{NegaScout} -- algorytm sterowania zakresem alfa i beta, wykorzystuj¹cy porz¹dkowanie nastêpników w oparciu o informacje z tablicy przejœæ. Najpierw przeszukiwany jest nastêpnik odpowiadaj¹cy najlepszemu znanemu ruchowi, a nastêpnie kolejne -- ze zredukowanym zakresem alfa i beta. Algorytm wykorzystuje tak¹ sam¹ tablicê przejœæ jak algorytm \emph{AlfaBeta}.

\end{enumerate}

\subsection{Funkcja oceny heurystycznej stanu}
Funkcja oceny jest oparta na s¹siedztwie pionków i wynika wprost celu gry jakim jest u³o¿enie linii 4 pionków. Funkcja premiuje pionki na planszy, które potencjalnie mog¹ s³u¿yæ do u³o¿enia linii, wysokoœæ premii zale¿y od iloœci pionków brakuj¹cych do u³o¿enia wygrywaj¹cej kombinacji. 

Dodatkowo funkcja uwzglêdnia gracza aktualnie wykonuj¹cego ruch. Specyfika gry wymaga, aby gracz rozpoczynaj¹cy gra³ bardziej ofensywnie (próbowa³ u³o¿yæ liniê), a gracz graj¹cy jako drugi powinien graæ bardziej defensywnie (uniemo¿liwiaæ przeciwnikowi u³o¿enie linii). Zatem gracz rozpoczynaj¹cy 

Funkcja zwraca wartoœci z przedzia³u $[-10000,10000]$. Wysokoœci premii zosta³y wyznaczone eksperymentalnie. 

jaki typ funkcji: zliczeniowa (bilans ró¿nicowy, ilorazowy), po³o¿eniowa (preferencja pewnych pól), odleg³oœciowa (jakie miary odleg³oœci i od/do czego je wyznaczamy), oparta na s¹siedztwie/otoczeniu, probabilistyczna, inna?
jaki przedzia³ wartoœci zwraca funkcja
jakie s¹ wartoœci skrajne (dla sukcesu, pora¿ki)
jak zosta³y wyznaczone wartoœci wag (o ile s¹ stosowane) poszczególnych sk³adowych funkcji
wady i zalety (jakie taktyczno-startegiczne cele gry uwzglêdnia a jakie ewentualnie nie s¹ brane pod uwagê)
przyk³ad stanu gry i ewaluacja wartoœci funkcji heurystycznej tego stanu z uwzglêdnieniem wartoœci poœrednich (wszystkich sk³adowych oceny ³¹cznej)


\section{Porównanie wydajnoœci algorytmów}
W celu zbadania wydajnoœci algorytmów przeprowadzono seriê testów z wykorzystaniem rozgrywek, w których obaj gracze byli sterowani komputerowo. W pary przeciwników po³¹czono algorytmy: \emph{AlfaBeta} i \emph{AlfaBeta} wariant {FailSafe} + \emph{TranspositionTable} oraz \emph{AlfaBeta} wariant {FailSafe} + \emph{TranspositionTable} i \emph{NegaScout}. Wyniki pomiarów przedstawiaj¹ nastêpuj¹ce tabele i wykresy.

AB-ABFSTT 3 - T
1	4257	4514
2	7899	5960
3	4148	4279
4	4190	4433
5	4959	5008
6	4706	4264
7	8769	5268
8	8779	2923
9	4368	3871
10	6183	4144
11	8866	6600
12	15399	2922
13	6182	4761
14	9086	3505
15	5612	3223
16	4073	2742
17	4806	4069
18	3230	2651
19	5128	3456
20	4662	3827
21	7670	3433
22	6900	5136
23	3170	2869
24	1385	1339
25	278	321
26	449	156
27	264	294

AB-ABFSTT 4 - T

ABFSTT-NS 3 - T
1	4514	4515
2	5960	4753
3	4279	4224
4	4433	4547
5	5008	4160
6	4264	4442
7	5268	4660
8	2923	2932
9	3871	3734
10	4144	3832
11	6600	5977
12	2922	2921
13	4761	4182
14	3505	3430
15	3223	3039
16	2742	2743
17	4069	3018
18	2651	2571
19	3456	2694
20	3827	3082
21	3433	3134
22	5136	3526
23	2869	2621
24	1339	1192
25	321	333
26	156	156
27	294	294

ABFSTT-NS 4 - T
1	17476	16269
2	27658	26104
3	23911	19810
4	22427	22921
5	24851	24172
6	21856	21827
7	16787	17109
8	12066	11465
9	13704	11459
10	26289	26800
11	5165	6579
12	22934	24688
13	11216	10466
14	8683	6172
15	22243	21156
16	16626	17584
17	7985	6735
18	18835	17039
19	45674	36308
20	9301	8372
21	8129	7733
22	1768	1827
23	15978	15263
24	5849	5304
25	2197	2010
26	1080	1050
27	2046	1765
28	4154	4119
29	2210	1962
30	3995	3117
31	16881	11731
32	2150	2152
33	555	594
34	1244	1149

\section{Wnioski, uwagi i podsumowanie}
Jaki jest szacunkowy rozmiar przestrzeni stanów zaimplementowanej gry? Jak zmienia siê rozmiar grafu w miarê postêpów gry? Roœnie, maleje, czy pozostaje raczej stabilny?
Która z zastosowanych metoda okaza³a siê najlepsza z punktu widzenia ograniczenia obszaru przeszukiwanej przestrzeni?
Czy ³atwo wygraæ cz³owiekowi (twórcy programu) z komputerem?
Czy wyst¹pi³ problem cykli w grafie gry i jak go rozwi¹zano? Czy og³aszany jest wtedy werdykt remisowy po pewnej sta³ej liczbie powtórzonych stanów?
Czy funkcja oceny okaza³a siê wystarczaj¹ca? Czy s¹ szanse na jest dalsz¹ poprawê? Je¿eli tak, to gdzie mo¿na by³oby wprowadziæ ulepszenia?
Czy by³y jakieœ trudne do wykrycia b³êdy implementacyjne?
Inne uwagi

\end{document}
