\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}
\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Implementacja gry ,,Quad''}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Sztuczna inteligencja \\ Implementacja gry ,,Quad''}
\author{Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\section{Opis gry}
Gra ,,Quad'' jest gr¹ dwuosobow¹ rozgrywan¹ na planszy o rozmiarach 8x8. Ka¿dy z graczy dysponuje 12-25 pionkami swojego koloru - liczbê tê ustala siê przed rozpoczêciem rozgrywki. Celem gry jest u³o¿enie 4 swoich pionków w linii prostej (poziomo lub pionowo). Aby tego dokonaæ gracze naprzemian wykonuj¹ jeden z ruchów:
\begin{enumerate}
\item ustawienie nowego pionka na planszy (jeœli gracz jeszcze nimi dysponuje),
\item przestawienie w³asnego pionka na s¹siednie, wolne pole (jeœli wszystkie pionki zosta³y ju¿ ustawione).
\end{enumerate}
Poprzez przestawienie pionka mo¿na zbiæ pionek przeciwnika. Dzieje siê tak wtedy, gdy w wyniku tego przestawienia pionek przeciwnika zostanie otoczony przynajmniej dwoma pionkami gracza. Je¿eli w wyniku zbijania przeciwnik straci wszystkie pionki, gracz równie¿ wygrywa.

Implementacja gry umo¿liwia w pe³ni dowolny wybór rozmiaru planszy i iloœci pionków. Pionki dwóch graczy s¹ odpowiednio bia³e lub czarne.

\section{Opis implementacji}
\subsection{Reprezentacja stanu gry}
Plansza gry reprezentowana jest jako dwuwymiarowa tablica o odpowiednich rozmiarach, przechowuj¹ca obiekty typu wyliczeniowego: brak pionka, pionek bia³y, pionek czarny. Podczas rysowania planszy na ekranie obiekty te zamieniane s¹ na odpowiednie obrazki.

\subsection{Generowanie ruchów dopuszczalnych}
Ruchy w grze reprezentowane s¹ zawsze przez trójkê: kolor gracza, pole Ÿród³owe, pole docelowe. Pozwala to reprezentowaæ zarówno ruchy polegaj¹ce przestawieniu pionka jak i ustawieniu pionka (pole Ÿród³owe równe null) i zbiciu pionka (pole docelowe równe null). Dla ka¿dego wykonywanego ruchy tworzony jest nowy obiekt, zawieraj¹cy kolekcjê: wykonywany ruch, konsekwencje ruchu. Konsekwencje ruchu pojawiaj¹ siê w momencie, gdy mamy do czynienia ze zbijaniem pionków.

Generowanie nastêpników polega na przejrzeniu wszystkich pól i okreœleniu dla ka¿dego z nich mo¿liwych ruchów z jego udzia³em w nastêpuj¹cy sposób:
\begin{enumerate}
\item jeœli dane pole jest puste i graczowi aktualnie wykonuj¹cemu ruch pozosta³y pionki do ustawienia to mo¿liwy ruch polega na ustawieniu w tym miejscu pionka,
\item jeœli dane pole jest zajête przez pionek gracza aktualnie wykonuj¹cego ruch i nie ma on wiêcej pionków do ustawienia, mo¿liwe ruchy polegaj¹ na przestawieniu pionka z tego pola na s¹siednie, wolne pole (przy czym kolejnoœæ poszukiwañ jest zawsze nastêpuj¹ca: pó³noc, po³udnie, wschód, zachód).
\end{enumerate}

Lista nastêpników jest mieszana, aby zmniejszyæ przewidywalnoœæ ruchów komputera. Nastêpnie lista jest porz¹dkowana w taki sposób, aby na jej pocz¹tku znalaz³y siê (i by³y przegl¹dane w pierwszej kolejnoœci) ruchy rozgrywaj¹ce siê w centrum planszy. Prowadzi to do zwiêkszenia wydajnoœci programu, jako ¿e ruchy te s¹ najczêœciej o wiele lepsze od pozosta³ych, a co za tym idzie pozwalaj¹ na czêstsze odciêcia.

\subsection{Algorytny przeszukiwania przestrzeni}
W programie zaimplementowano kilka algorytmów graj¹cych i ich wariantów:
\begin{enumerate}
\item \emph{NegMax} -- najprosztszy algorytm minimaksowy, zaimplementowany w celach testowych i porównawczych,

\item \emph{AlfaBeta} -- wykorzystuj¹cy odciêcia alfa i beta podczas przeszukiwania przestrzeni stanów,

\item \emph{AlfaBeta}, wariant \emph{FailSoft} -- wariant algorytmu AlfaBeta, który mo¿e zwracaæ rozwi¹zanie spoza przedzia³u $(alfa, beta)$, wykorzystywany do obliczania górnych i dolnych ograniczeñ oceny najlepszego ruchu,

\item \emph{AlfaBeta}, wariant \emph{FailSoft} + \emph{TranspositionTable} -- algorytm sterowania kolejnoœci¹ nastêpników, wykorzystuj¹cy dodatkowo tablicê przejœæ do pamiêtania stanów ju¿ odwiedzonych i odpowiadaj¹cych im najlepszych ruchów. Kluczem w tablicy jest tekstowa reprezentacja planszy -- ci¹g znaków odpowiadaj¹cych kolorom pionków (lub brakowi pionka) wraz z nazw¹ gracza aktualnie wykonuj¹cego ruch, odpowiada mu zestaw danych: najlepszy ruch, wartoœæ oceny dla tego ruchu, rodzaj ograniczenia (górne, dolne lub dok³adne) i g³êbokoœæ przeszukiwania. Tablica wykorzystuje standardow¹ kolekcjê System.Collections.Hashtable oraz standardow¹ funkcjê haszuj¹c¹ klasy string. Dziêki zastosowaniu iteracyjnego pog³êbiania i tablicy przejœæ najlepszy ruch jest sprawdzany jako pierwszy w ka¿dym wierzcho³ku. 

\item \emph{NegaScout} -- algorytm sterowania zakresem alfa i beta, wykorzystuj¹cy porz¹dkowanie nastêpników w oparciu o informacje z tablicy przejœæ. Najpierw przeszukiwany jest nastêpnik odpowiadaj¹cy najlepszemu znanemu ruchowi, a nastêpnie kolejne -- ze zredukowanym zakresem alfa i beta. Algorytm wykorzystuje tak¹ sam¹ tablicê przejœæ jak algorytm AlfaBeta.

\end{enumerate}

\subsection{Funkcja oceny heurystycznej stanu gry}
Funkcja oceny jest oparta na s¹siedztwie pionków i wynika wprost celu gry jakim jest u³o¿enie linii 4 pionków. Funkcja premiuje pionki na planszy, które potencjalnie mog¹ s³u¿yæ do u³o¿enia linii, wysokoœæ premii zale¿y od iloœci pionków brakuj¹cych do u³o¿enia wygrywaj¹cej kombinacji. 

Dodatkowo funkcja uwzglêdnia gracza aktualnie wykonuj¹cego ruch. Specyfika gry wymaga, aby gracz rozpoczynaj¹cy gra³ bardziej ofensywnie (próbowa³ u³o¿yæ liniê), a gracz graj¹cy jako drugi powinien graæ bardziej defensywnie (uniemo¿liwiaæ przeciwnikowi u³o¿enie linii). Zatem gracz rozpoczynaj¹cy 

Funkcja zwraca wartoœci z przedzia³u $[-10000,10000]$. Wysokoœci premii zosta³y wyznaczone eksperymentalnie. 

jaki typ funkcji: zliczeniowa (bilans ró¿nicowy, ilorazowy), po³o¿eniowa (preferencja pewnych pól), odleg³oœciowa (jakie miary odleg³oœci i od/do czego je wyznaczamy), oparta na s¹siedztwie/otoczeniu, probabilistyczna, inna?
jaki przedzia³ wartoœci zwraca funkcja
jakie s¹ wartoœci skrajne (dla sukcesu, pora¿ki)
jak zosta³y wyznaczone wartoœci wag (o ile s¹ stosowane) poszczególnych sk³adowych funkcji
wady i zalety (jakie taktyczno-startegiczne cele gry uwzglêdnia a jakie ewentualnie nie s¹ brane pod uwagê)
przyk³ad stanu gry i ewaluacja wartoœci funkcji heurystycznej tego stanu z uwzglêdnieniem wartoœci poœrednich (wszystkich sk³adowych oceny ³¹cznej)


\section{Testy wydajnoœci i porównania algorytmów}
Punktem odniesienia dla wszystkich stosowanych metod ma byæ "czysty" algorytm alfa-beta
Pomiary maj¹ dotyczyæ œredniej liczby odwiedzonych wierzcho³ków w grafie gry a NIE CZASÓW przeszukiwania
Porównania nale¿y przeprowadziæ dla co najmniej trzech ró¿nych stanów pocz¹tkowych (m.in. ró¿nych od stanu wynikaj¹cego z zasad rozpoczynania gry)
Porównania powinny byæ prowadzone dla kilku ró¿nych g³êbokoœci przeszukiwania
Testy nale¿y przeprowadziæ dla g³êbokoœci grafu wynosz¹cej co najmniej 5 niezale¿nie od tego czy wymaga to czasów obliczeñ rzêdu minuty, godziny, a mo¿e nawet doby - od czego w koñcu s¹ komputery ;-)
Je¿eli metoda charakteryzuje siê dodatkowymi parametrami (poza g³êbokoœci¹ przeszukiwania) nale¿y podaæ dla jakich wartoœci zosta³y przeprowadzone porównania
Wyniki porównañ powinny byæ przedstawione ZARÓWNO w postaci wykresów, jak i tabel
Ka¿da krzywa na wykresie powinna mieæ inny typ znacznika punktów pomiarowych tak, aby by³y czytelna na wydruku czarno-bia³ym niezale¿nie od faktycznie przypisanego jej koloru

\section{Wnioski, uwagi i podsumowanie}
Jaki jest szacunkowy rozmiar przestrzeni stanów zaimplementowanej gry? Jak zmienia siê rozmiar grafu w miarê postêpów gry? Roœnie, maleje, czy pozostaje raczej stabilny?
Która z zastosowanych metoda okaza³a siê najlepsza z punktu widzenia ograniczenia obszaru przeszukiwanej przestrzeni?
Czy ³atwo wygraæ cz³owiekowi (twórcy programu) z komputerem?
Czy wyst¹pi³ problem cykli w grafie gry i jak go rozwi¹zano? Czy og³aszany jest wtedy werdykt remisowy po pewnej sta³ej liczbie powtórzonych stanów?
Czy funkcja oceny okaza³a siê wystarczaj¹ca? Czy s¹ szanse na jest dalsz¹ poprawê? Je¿eli tak, to gdzie mo¿na by³oby wprowadziæ ulepszenia?
Czy by³y jakieœ trudne do wykrycia b³êdy implementacyjne?
Inne uwagi

\end{document}
