\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{slashbox}
\usepackage{sistyle}
\usepackage{amsfonts}
\usepackage{latexsym}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}

\SIdecimalsign{,}

\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Algorytm dok³adny}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Optymalizacja kombinatoryczna \\ Algorytm dok³adny}
\author{ Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Opis problemu}
Rozwa¿any problem zosta³ szczegó³owo opisany w sprawozdaniu dot. algorytmu aproksymacyjnego. Dla przypomnienia, jego opis w notacji trójpolowej jest nastêpuj¹cy:
\begin{quote}
$F2$, $h_{1k}$ | $SRS$ , $r_i$, $no-wait$ | $C_{max}$
\end{quote}

\section{Opis algorytmu}
W fazie drugiej projektu konieczne by³o zaimplementowanie algorytmu dok³adnego, tj. takiego, który znajduje dla postawionego problemu rozwi¹zanie optymalne. Jako ogólny schemat postêpowania przyjêto \emph{metodê rozga³êzieñ i ograniczeñ}.

\subsection{Idea algorytmu}
Idea algorytmu korzystaj¹cego z metody rozga³êzieñ i ograniczeñ opiera siê na systematycznym przeszukiwaniu drzewa dopuszczalnych rozwi¹zañ. W trakcie obliczeñ pomijane s¹ poddrzewa odpowiadaj¹ce rozwi¹zaniom, o których na danym etapie przeszukiwania z pewnoœci¹ mo¿na stwierdziæ, ¿e prowadz¹ do rozwi¹zañ nieoptymalnych.

Dla postawionego problemu szeregowania zadañ drzewo to jest budowane w nastêpuj¹cy sposób:
\begin{itemize}
\item korzeñ drzewa odpowiada pustej permutacji zadañ,
\item ka¿dy wierzcho³ek wewnêtrzny ma $n-i$ potomków, gdzie $i$ to poziom wierzcho³ka w drzewie, odpowiadaj¹cych $n-i$ pozosta³ym do uszeregowanym zadaniom,
\item wysokoœæ drzewa równa jest $n$, œcie¿ka od korzenia do liœcia wyznacza pewn¹ permutacjê zadañ o okreœlonej wartoœci optymalizowanego parametru \emph{cmax}.
\end{itemize}

Poniewa¿ zadanie polega na znalezieniu minimalnej wartoœci parametru \emph{cmax}, kluczem do skutecznego wykonywania odciêæ jest umiejêtnoœæ znajdywania dla danej pocz¹tkowej permutacji dolnego ograniczenia tego parametru, zwanego dalej \emph{cmax\_min}. Jeœli jego wartoœæ jest niemniejsza od aktualnie znalezionej najmniejszej wartoœci \emph{cmax}, zwanej dalej \emph{cmax\_best}, dalsze obliczenia s¹ bezcelowe, gdy¿ doprowadz¹ do uszeregowania o wartoœci \emph{cmax} niemniejszej ni¿ ju¿ znaleziona. Rozumowanie odwrotne nie jest poprawne, tzn. spe³nienie dolnego ograniczenia nie daje gwarancji znalezienia lepszego rozwi¹zania, co przy s³abym ograniczeniu powoduje wykonanie wielu zbêdnych obliczeñ. Moment decyzyjny mo¿na przedstawiæ w pseudokodzie nastêpuj¹co:
\begin{verbatim}
if (cmax_min < cmax_best)
    continue; //znalezienie lepszego rozwi¹zania jest mo¿liwe
else
    break; //w danym poddrzewie nie ma lepszego rozwi¹zania
\end{verbatim}

Na zmniejszenie iloœci zbêdnych wywo³añ rekurencyjnej funkcji przeszukuj¹cej drzewo rozwi¹zañ maj¹ zatem wp³yw dwa czynniki:
\begin{enumerate}
\item Mo¿liwie wczesne przypisanie \emph{cmax\_best} wartoœci jak najbli¿szej optymalnej.
\item Wykorzystanie mo¿liwie rygorystycznej funkcji dolnego ograniczenia.
\end{enumerate}

W implementacji algorytmu wykorzystanych zosta³o kilka ró¿nych podejœæ pozwalaj¹cych spe³niæ powy¿sze zalecenia. Zosta³y one opisane w kolejnych punktach.

\subsection{Rozwi¹zanie wstêpne}
W celu przypisania \emph{cmax\_best} mo¿liwie wczeœnie wartoœci bliskiej optymalnej, zdecydowano siê okreœliæ t¹ wartoœæ jeszcze przed przyst¹pieniem do przeszukiwania drzewa rozwi¹zañ. Na podstawie wniosków z pierwszej fazy projektu do testów wykorzystano trzy metody wstêpnego oszacowania wartoœci \emph{cmax}, opieraj¹ce siê na permutacji otrzymanej poprzez, odpowiednio:
\begin{enumerate}
\item Posortowanie zadañ wed³ug czasów przybycia.
\item Uszeregowanie zadañ w sposób zach³anny.
\item Uszeregowanie zadañ przy pomocy algorytmu tabu search.
\end{enumerate}
Wyboru metody dokonuje siê poprzez ustawienie parametru algorytmu zwanego dalej \emph{init}. Ponadto mo¿liwe jest okreœlenie czy powy¿sza metoda inicjalizacji jedynie definiuje wstêpn¹ wartoœæ \emph{cmax\_best}, czy powoduje te¿ narzucenie porz¹dku przeszukiwania -- rozpoczyna siê ono wtedy od rozwi¹zania wstêpnego. Decyduje o tym parametr \emph{setup}, przyjmuj¹cy dla opisanych sytuacji wartoœci odpowiednio 1 i 2.

\subsection{Dolne ograniczenie}
W trakcie implementacji algorytmu opracowano kilka funkcji ograniczaj¹cych o zró¿nicowanej skutecznoœci. Ich wyboru dokonuje siê parametrem \emph{limit}. Najprostsza z nich, wybierana wartoœci¹ $\emph{limit}=0$, wynika z obserwacji, ¿e wartoœæ parametru \emph{cmax} dla pe³nego uszeregowania jest niemniejsza ni¿ dla pewnego uszeregowania cz¹stkowego. Innymi s³owy szeregowanie kolejnych zadañ mo¿e j¹ jedynie zwiêkszaæ, co jest oczywist¹ konsekwencj¹ nieujemnych czasów przetwarzania. Kolejne funkcje ograniczaj¹ce uwzglêdniaj¹ powy¿sz¹ obserwacjê oraz pewne dodatkowe, opisane w kolejnych punktach, dotycz¹ce zadañ jeszcze nieuszeregowanych. W ogólnoœci mo¿na powiedzieæ, ¿e wartoœæ ograniczenia \emph{cmax\_min} jest równa sumie parametru \emph{cmax} dla cz¹stkowego uszeregowania otrzymanego na danym etapie przeszukiwania i pewnej wartoœci optymistycznie szacuj¹cej minimalny czas konieczny do wykonania pozosta³ych zadañ, zwanej dalej \emph{approx}:
$$\emph{cmax\_min} = \emph{cmax} + \emph{approx}$$
Ograniczenie to jest wyliczane dla obu maszyn osobno, a nastêpnie zostaje wybrana wiêksza z wartoœci, przy czym za \emph{cmax} dla danej maszyny przyjmuje siê czas zakoñczenia ostatniego zadania na tej maszynie.

\subsubsection{Wariant $\emph{limit}=1$}
Druga z zaimplementowanych funkcji ograniczaj¹cych, wybierana wartoœci¹ $\emph{limit}=1$, szacuje minimalny pozosta³y czas, czyli \emph{approx}, jako:
\begin{enumerate}
\renewcommand{\labelenumi}{\alph{enumi})}
\item sumê czasów przetwarzania pozosta³ych zadañ i czasów niedostêpnoœci   bêd¹cych w ich zasiêgu, obliczonym przy za³o¿eniu, wykonaj¹ siê bez dodatkowych opóŸnieñ  -- dla pierwszej maszyny,
\item sumê czasów przetwarzania pozosta³ych zadañ -- dla drugiej maszyny.
\end{enumerate}

\subsubsection{Wariant $\emph{limit}=2$}
Kolejna funkcja ograniczaj¹ca, wybierana wartoœci¹ $\emph{limit}=2$, dodaje przy szacowaniu minimalnego pozosta³ego czasu dodatkowo opóŸnienia wynikaj¹ce z nastêpuj¹cych faktów, dotycz¹cych pozosta³ych zadañ:
\begin{itemize}
\item przetwarzanie na pierwszej maszynie nie mo¿e siê rozpocz¹æ przed przybyciem najwczeœniejszego zadania,
\item je¿eli w zasiêgu najkrótszego zadania znajduje siê okres niedostêpnoœci, to podzia³ zadania na tym okresie jest nieunikniony,
\item przetwarzanie na drugiej maszynie mo¿e siê rozpocz¹æ dopiero z chwil¹ najwczeœniejszego mo¿liwego ukoñczenia zadania na maszynie pierwszej,
\item dla wszystkich zadañ musi byæ spe³niony warunek \emph{nowait}, dlatego przetwarzanie na pierwszej maszynie mo¿e siê rozpocz¹æ najwczeœniej w chwili, dla której dla najbardziej dopasowanego zadania ten warunek bêdzie zachodzi³,
\item po zakoñczeniu przetwarzania na maszynie pierwszej, na maszynie drugiej musi zostaæ wykonana przynajmniej praca zwi¹zana z zadaniem o najkrótszym czasie przetwarzania dla tej maszyny.
\end{itemize}

\subsubsection{Wariant $\emph{limit}=3$}
Ostatnia z funkcji ograniczaj¹cych, wybierana wartoœci¹ $\emph{limit}=3$, wykorzystuje dla pierwszego zadania pe³en algorytm szeregowania danego, dziêki czemu uwzglêdnia wszystkiego opóŸnienia wynikaj¹ce z warunków zawartych w postawionym problemie, w tym m.in. czasy przygotowania wymuszone podzia³em zadania przez wszystkie maj¹ce na nie wp³yw okresy niedostêpnoœci. O ile prowadzi to do ograniczenia najdok³adniejszego spoœród opisanych, wymaga to wiêkszej iloœci obliczeñ i co za tym idzie -- otrzymana funkcja ograniczaj¹ca powoduje dla pewnych instancji d³u¿szy dzia³ania algorytmu ni¿ jego pozornie gorsze warianty. Dla pozosta³ych zadañ stosowane s¹ zwyk³e sumy, tak jak w przypadku pozosta³ych funkcji ograniczaj¹cych. Uwzglêdniane jest równie¿ opóŸnienie wynikaj¹ce z wykonania na drugiej maszynie na zakoñczenie przynajmniej zadania o najkrótszym czasie przetwarzania dla tej maszyny.

\subsection{Optymalizacje techniczne}
Wartym wspomnienia jest sposób przechowywania permutacji zadañ w trakcie przeszukiwania drzewa rozwi¹zañ. W celu zapewnienia sta³ego czasu wykonania operacji dodania i usuniêcia zadania na koñcu cz¹stkowej permutacji wykorzystywana jest jedna tablica o sta³ym rozmiarze równym iloœæ zadañ wystêpuj¹cych w instancji, przechowuj¹ca ich indeksy. Dodatkowo pamiêtany jest indeks, oznaczony dalej \emph{line}, rozdzielaj¹cy tablicê na czêœæ pocz¹tkow¹, reprezentuj¹c¹ aktualn¹ cz¹stkow¹ permutacjê, oraz czêœæ koñcow¹, zawieraj¹c¹ listê zadañ pozosta³ych do uszeregowania. Etap rozga³êzienia algorytmu polega na iteracyjnym przejrzeniu tej listy i wykonaniu dla ka¿dego z jej elementów nastêpuj¹cych kroków:
\begin{enumerate}
\item Zamiany wybranego elementu z elementem o pozycji \emph{line}.
\item Zwiêkszenia wartoœci \emph{line} o 1.
\item Rekurencyjnego wywo³ania algorytmu.
\item Zmniejszenia wartoœci \emph{line} o 1.
\item Ponownej zamiany wybranego elementu z elementem o pozycji \emph{line}.
\end{enumerate}

\section{Wyniki eksperymentu}
W celu przetestowania efektywnoœci zaimplementowanego algorytmu przeprowadzono szereg pomiarów dla ró¿nych wielkoœci instancji. Zbadany zosta³ zakres od 5 zadañ do 13 -- w przypadku metody $\emph{limit}=0$ -- oraz do 25 -- w pozosta³ych przypadkach. W celu zwiêkszenia obiektywnoœci przeprowadzanych testów ka¿da iloœæ zadañ z badanego zakresu by³a reprezentowana przez 20 losowo wygenerowanych instancji. W ramach ka¿dej z nich przetestowano wszystkie kombinacje parametrów \emph{init}, \emph{setup} i \emph{limit}, z wyj¹tkiem opisanym wczeœniej. Wymienione górne granice zosta³y przyjête jako maksymalna iloœæ zadañ, dla której dany wariant algorytmu zdo³a³ wyliczyæ przynajmniej 3 instancje. Jako limit czasowy przyjêto 60 sekund -- obliczenia trwaj¹ce d³u¿ej by³y przerywane, a dana instancja oznaczana jako ,,niewyliczalna'' przez badany wariant algorytmu. 

\end{document}
