\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{slashbox}
\usepackage{sistyle}
\usepackage{amsfonts}
\usepackage{latexsym}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}

\SIdecimalsign{,}

\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Algorytm dok³adny}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Optymalizacja kombinatoryczna \\ Algorytm dok³adny}
\author{ Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Opis problemu}
Rozwa¿any problem zosta³ szczegó³owo opisany w sprawozdaniu dot. algorytmu aproksymacyjnego. Dla przypomnienia, jego opis w notacji trójpolowej jest nastêpuj¹cy:
\begin{quote}
$F2$, $h_{1k}$ | $SRS$ , $r_i$, $no-wait$ | $C_{max}$
\end{quote}

\section{Opis algorytmu}
W fazie drugiej projektu konieczne by³o zaimplementowanie algorytmu dok³adnego, tj. takiego, który znajduje dla postawionego problemu rozwi¹zanie optymalne. Jako ogólny schemat postêpowania przyjêto \emph{metodê rozga³êzieñ i ograniczeñ}.

\subsection{Idea algorytmu}
Idea algorytmu korzystaj¹cego z metody rozga³êzieñ i ograniczeñ opiera siê na systematycznym przeszukiwaniu drzewa dopuszczalnych rozwi¹zañ. W trakcie obliczeñ pomijane s¹ poddrzewa odpowiadaj¹ce rozwi¹zaniom, o których na danym etapie przeszukiwania z pewnoœci¹ mo¿na stwierdziæ, ¿e prowadz¹ do rozwi¹zañ nieoptymalnych.

Dla postawionego problemu szeregowania zadañ drzewo to jest budowane w nastêpuj¹cy sposób:
\begin{itemize}
\item korzeñ drzewa odpowiada pustej permutacji zadañ,
\item ka¿dy wierzcho³ek wewnêtrzny ma $n-i$ potomków, gdzie $i$ to poziom wierzcho³ka w drzewie, odpowiadaj¹cych $n-i$ pozosta³ym do uszeregowanym zadaniom,
\item wysokoœæ drzewa równa jest $n$, œcie¿ka od korzenia do liœcia wyznacza pewn¹ permutacjê zadañ o okreœlonej wartoœci optymalizowanego parametru \emph{cmax}.
\end{itemize}

Poniewa¿ zadanie polega na znalezieniu minimalnej wartoœci parametru \emph{cmax}, kluczem do skutecznego wykonywania odciêæ jest umiejêtnoœæ znajdywania dla danej pocz¹tkowej permutacji dolnego ograniczenia tego parametru, zwanego dalej \emph{cmax\_min}. Jeœli jego wartoœæ jest niemniejsza od aktualnie znalezionej najmniejszej wartoœci \emph{cmax}, zwanej dalej \emph{cmax\_best}, dalsze obliczenia s¹ bezcelowe, gdy¿ doprowadz¹ do uszeregowania o wartoœci \emph{cmax} niemniejszej ni¿ ju¿ znaleziona. Rozumowanie odwrotne nie jest poprawne, tzn. spe³nienie dolnego ograniczenia nie daje gwarancji znalezienia lepszego rozwi¹zania, co przy s³abym ograniczeniu powoduje wykonanie wielu zbêdnych obliczeñ. Moment decyzyjny mo¿na przedstawiæ w pseudokodzie nastêpuj¹co:
\begin{verbatim}
if (cmax_min < cmax_best)
    continue; //znalezienie lepszego rozwi¹zania jest mo¿liwe
else
    break; //w danym poddrzewie nie ma lepszego rozwi¹zania
\end{verbatim}

Na zmniejszenie iloœci zbêdnych wywo³añ rekurencyjnej funkcji przeszukuj¹cej drzewo rozwi¹zañ maj¹ zatem wp³yw dwa czynniki:
\begin{enumerate}
\item Przyjêcie wstêpnej wartoœci \emph{cmax\_best} jak najbli¿szej optymalnej.
\item Wykorzystanie mo¿liwie rygorystycznej funkcji dolnego ograniczenia.
\end{enumerate}

W implementacji algorytmu wykorzystanych zosta³o kilka ró¿nych metod spe³niaj¹cych powy¿sze zalecenia, opisanych w kolejnych punktach.

\subsection{Rozwi¹zanie wstêpne}
Na podstawie wniosków z pierwszej fazy projektu do testów przyjêto trzy metody wstêpnego oszacowania wartoœci \emph{cmax}, opieraj¹ce siê na permutacji otrzymanej poprzez, odpowiednio:
\begin{enumerate}
\item Posortowanie zadañ wed³ug czasów przybycia.
\item Uszeregowanie zadañ w sposób zach³anny.
\item Uszeregowanie zadañ przy pomocy algorytmu tabu search.
\end{enumerate}
Wyboru metody dokonuje siê poprzez ustawienie parametru algorytmu zwanego dalej \emph{init}. Ponadto mo¿liwe jest okreœlenie czy powy¿sza metoda inicjalizacji jedynie definiuje wstêpn¹ wartoœæ \emph{cmax\_best}, czy powoduje te¿ narzucenie porz¹dku przeszukiwania -- rozpoczyna siê ono wtedy od rozwi¹zania wstêpnego. Decyduje o tym parametr \emph{setup}, przyjmuj¹cy dla opisanych sytuacji wartoœci odpowiednio 1 i 2.

\subsection{Dolne ograniczenie}
W trakcie implementacji algorytmu opracowano kilka funkcji ograniczaj¹cych, o zró¿nicowanej skutecznoœci. Ich wyboru dokonuje siê parametrem \emph{limit}. Opieraj¹ siê one na nastêpuj¹cych obserwacjach, uporz¹dkowanych zgodnie z rosn¹c¹ si³¹ odpowiadaj¹cych im ograniczeñ:
\begin{itemize}
\item wartoœæ parametru \emph{cmax} dla pe³nego uszeregowania jest niemniejsza ni¿ dla pewnego uszeregowania cz¹stkowego ($\emph{limit}=0$),
\item 
\item 
\end{itemize}

\subsection{Optymalizacje techniczne}

\section{Wyniki eksperymentu}

\end{document}
