\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{slashbox}
\usepackage{sistyle}
\usepackage{amsfonts}
\usepackage{latexsym}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}

\SIdecimalsign{,}

\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{15.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{Algorytm dok³adny}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{titlepage}
\title{Optymalizacja kombinatoryczna \\ Algorytm dok³adny}
\author{ Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Opis problemu}
Rozwa¿any problem zosta³ szczegó³owo opisany w sprawozdaniu dot. algorytmu aproksymacyjnego. Dla przypomnienia, jego opis w notacji trójpolowej jest nastêpuj¹cy:
\begin{quote}
$F2$, $h_{1k}$ | $SRS$ , $r_i$, $no-wait$ | $C_{max}$
\end{quote}

\section{Opis algorytmu}
W fazie drugiej projektu konieczne by³o zaimplementowanie algorytmu dok³adnego, tj. takiego, który znajduje dla postawionego problemu rozwi¹zanie optymalne. Jako ogólny schemat postêpowania przyjêto \emph{metodê rozga³êzieñ i ograniczeñ}.

\subsection{Idea algorytmu}
Idea algorytmu korzystaj¹cego z metody rozga³êzieñ i ograniczeñ opiera siê na systematycznym przeszukiwaniu drzewa dopuszczalnych rozwi¹zañ. W trakcie obliczeñ pomijane s¹ poddrzewa odpowiadaj¹ce rozwi¹zaniom, o których na danym etapie przeszukiwania z pewnoœci¹ mo¿na stwierdziæ, ¿e prowadz¹ do rozwi¹zañ nieoptymalnych.

Dla postawionego problemu szeregowania zadañ drzewo to jest budowane w nastêpuj¹cy sposób:
\begin{itemize}
\item korzeñ drzewa odpowiada pustej permutacji zadañ,
\item ka¿dy wierzcho³ek wewnêtrzny ma $n-i$ potomków, gdzie $i$ to poziom wierzcho³ka w drzewie, odpowiadaj¹cych $n-i$ pozosta³ym do uszeregowanym zadaniom,
\item wysokoœæ drzewa równa jest $n$, œcie¿ka od korzenia do liœcia wyznacza pewn¹ permutacjê zadañ o okreœlonej wartoœci optymalizowanego parametru \emph{cmax}.
\end{itemize}

Poniewa¿ zadanie polega na znalezieniu minimalnej wartoœci parametru \emph{cmax}, kluczem do skutecznego wykonywania odciêæ jest umiejêtnoœæ znajdywania dla danej pocz¹tkowej permutacji dolnego ograniczenia tego parametru, zwanego dalej \emph{cmax\_min}. Jeœli jego wartoœæ jest niemniejsza od aktualnie znalezionej najmniejszej wartoœci \emph{cmax}, zwanej dalej \emph{cmax\_best}, dalsze obliczenia s¹ bezcelowe, gdy¿ doprowadz¹ do uszeregowania o wartoœci \emph{cmax} niemniejszej ni¿ ju¿ znaleziona. Rozumowanie odwrotne nie jest poprawne, tzn. spe³nienie dolnego ograniczenia nie daje gwarancji znalezienia lepszego rozwi¹zania, co przy s³abym ograniczeniu powoduje wykonanie wielu zbêdnych obliczeñ. Moment decyzyjny mo¿na przedstawiæ w pseudokodzie nastêpuj¹co:
\begin{verbatim}
if (cmax_min < cmax_best)
    continue; //znalezienie lepszego rozwi¹zania jest mo¿liwe
else
    break; //w danym poddrzewie nie ma lepszego rozwi¹zania
\end{verbatim}

Na zmniejszenie iloœci zbêdnych wywo³añ rekurencyjnej funkcji przeszukuj¹cej drzewo rozwi¹zañ maj¹ zatem wp³yw dwa czynniki:
\begin{enumerate}
\item Przyjêcie wstêpnej wartoœci \emph{cmax\_best} jak najbli¿szej optymalnej.
\item Wykorzystanie mo¿liwie rygorystycznej funkcji dolnego ograniczenia.
\end{enumerate}

W implementacji algorytmu wykorzystanych zosta³o kilka ró¿nych metod spe³niaj¹cych powy¿sze zalecenia, opisanych w kolejnych punktach.

\subsection{Rozwi¹zanie wstêpne}
Na podstawie wniosków z pierwszej fazy projektu do testów przyjêto trzy metody wstêpnego oszacowania wartoœci \emph{cmax}, opieraj¹ce siê na permutacji otrzymanej poprzez, odpowiednio:
\begin{enumerate}
\item Posortowanie zadañ wed³ug czasów przybycia.
\item Uszeregowanie zadañ w sposób zach³anny.
\item Uszeregowanie zadañ przy pomocy algorytmu tabu search.
\end{enumerate}
Wyboru metody dokonuje siê poprzez ustawienie parametru algorytmu zwanego dalej \emph{init}. Ponadto mo¿liwe jest okreœlenie czy powy¿sza metoda inicjalizacji jedynie definiuje wstêpn¹ wartoœæ \emph{cmax\_best}, czy powoduje te¿ narzucenie porz¹dku przeszukiwania -- rozpoczyna siê ono wtedy od rozwi¹zania wstêpnego. Decyduje o tym parametr \emph{setup}, przyjmuj¹cy dla opisanych sytuacji wartoœci odpowiednio 1 i 2.

\subsection{Dolne ograniczenie}
W trakcie implementacji algorytmu opracowano kilka funkcji ograniczaj¹cych, o zró¿nicowanej skutecznoœci. Ich wyboru dokonuje siê parametrem \emph{limit}. Opieraj¹ siê one na nastêpuj¹cych obserwacjach, uporz¹dkowanych zgodnie z rosn¹c¹ si³¹ odpowiadaj¹cych im ograniczeñ:
\begin{itemize}
\item wartoœæ parametru \emph{cmax} dla pe³nego uszeregowania jest niemniejsza ni¿ dla pewnego uszeregowania cz¹stkowego ($\emph{limit}=0$),
\item 
\item 
\end{itemize}

optymalizacje

approx1

time_passed, time_left to wiadomo

offline_sum liczy offlines od time[0] do time[0] + time_left(0), ¿eby nie policzyæ offlines które s¹ za przewidywanym koñcem

approx2

approx1 +

m1_start - zwraca minimalne przesuniêcie rozpoczêcia pracy na pierwszej maszynie w stosunku do time[0]. Przesuniêcie mo¿e wynikaæ z tego, ¿e dla wszystkich zadañ arrival > time[0] lub z koniecznoœci podzielenia zadania. (trochê mo¿na poprawiæ tê funkcjê, jak starczy czasu to tak zrobimy, bo teraz te dwie sytuacje, tzn. za du¿e arrivals i podzia³ s¹ wykrywane roz³¹cznie, a mo¿na wykrywaæ obie naraz)

m2_start - zwraca minimalne przesuniêcie rozpoczêcia pracy na drugiej maszynie w stosunku do time[1]. Za najwczeœniejszy mo¿liwy pocz¹tek uznaje najmniejsz¹ z wartoœci x = max(time[0], arrival) + sums[0] liczon¹ dla wszystkich pozosta³ych zadañ. Je¿eli x > time[1] to zwraca x - time[1], wpp. 0. Nie uwzglêdnia istnienia offlines.

nowait_shift - wykrywa sytuacjê w której warunek nowait lub arrival wymusza rozpoczêcie zadania po time[0] (zamiast dok³adnie w time[0]). Nie uwzglêdnia istnienia offlines. Tu jest ciê¿ka sprawa, bo nowait_shift robi podobn¹ rzecz jak m1_start i trzeba uwa¿aæ ¿eby nie policzyæ 2 razy tego samego, wiêc mo¿e jednak nie da siê poprawiæ m1_start tak jak myœla³em. Ogólnie jest to nietrywialne i mo¿e lepiej nie tykaæ :D 

shortest_left - wybiera najkrótsze zadanie wg czêœci na drugiej maszynie. Zwrócon¹ wartoœæ mo¿na bezpiecznie dodaæ do czasu na pierwszej maszynie, bo druga musi skoñczyæ dzia³anie po pierwszej o co najmniej tyle jednostek czasu ile wynosi d³. najkrótszego zadania.

approx 3

m1start , m2_start i no-waitshift zawieraj¹ siê w machine_starts wiêc nie mo¿na ich dodawaæ drugi raz, shortest_left mo¿e zostaæ

machine_starts - wylicza wszystkie przesuniêcia zwi¹zane z ustawieniem zadania (po prostu je ustawia i odejmuje jego d³ugoœæ i ewentualnie d³ugoœæ offline'ów)
Wylicza minimalne mo¿liwe przesuniêcia oddzielnie dla obu maszyn.

Tak w ogóle to trzeba napisaæ, ¿e liczymy oddzielnie dla obu maszyn ograniczenie i wybieramy z nich maksa, mo¿e ciekawa bêdzie statystyka która maszyna czêœciej daje wiêksz¹ wartoœæ, chocia¿ to zale¿y g³ównie od parametrów testu, a nie optymalizacji (parametrów w sensie suma zadañ na pierwszej + suma offlineów a suma zadañ na drugiej).




\subsection{Optymalizacje techniczne}

\section{Wyniki eksperymentu}

\end{document}
