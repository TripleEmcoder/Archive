\documentclass[12pt,a4paper,titlepage,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\usepackage[english,polish]{babel}
\usepackage[T1]{polski}
\usepackage{times}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{slashbox}
\usepackage{sistyle}
\usepackage{amsfonts}
\usepackage{latexsym}

\setlength{\textheight}{24cm}
\setlength{\textwidth}{15.92cm}
\setlength{\footskip}{10mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headsep}{5mm}
\setlength{\headheight}{14.0pt}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\textsf{\thepage}}
\fancyhead[RE,LO]{\textsf{(tytu³)}}
\fancyhead[CE,CO]{\ }
\fancyfoot[LE,RO]{\ }
\fancyfoot[RE,LO]{\ }
\fancyfoot[CE,CO]{\ }
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\hypersetup
{
	bookmarksnumbered=true,
	colorlinks=true,
	linkcolor=blue,
	bookmarksopen=true,
	bookmarksopenlevel=2,
	pdfstartview={FitH}
}

\SIdecimalsign{,}

\begin{titlepage}
\title{Optymalizacja kombinatoryczna \\ (tytu³)}
\author{ Bartosz Kukawka (75911) \\ Marcin Miko³ajczak (75922) \\ Grupa I3A}
\end{titlepage}

\begin{document}

\maketitle

\section{Opis problemu}

\subsection{Notacja trójpolowa}
Celem projektu by³o opracowanie algorytmu znajduj¹cego rozwi¹zania mo¿liwie bliskie optymalnym dla optymalizacyjnego problemu szeregowania zadañ okreœlonego w notacji trójpolowej nastêpuj¹co:

\begin{quote}
$F2$, $h_{1k}$ | $SRS$ , $r_i$, $no-wait$ | $C_{max}$
\end{quote}

Poszczególne symbole opisu precyzuj¹ problem w nastêpuj¹cy sposób:
\begin{description}
\item[$F2$] -- szeregowanie zadañ w systemie przep³ywowym na 2 maszynach (ka¿de zadanie przetwarzane jest dwufazowo -- najpierw na I maszynie, potem na II maszynie),
\item[$h_{1k}$] -- wystêpowanie okresów niedostêpnoœci na I maszynie,
\item[$SRS$] -- mo¿liwoœæ wznawiania zadañ (z zastrze¿eniem, ¿e zatrzymanie zadania mo¿e nast¹piæ jedynie w przypadku wyst¹pienia okresu niedostêpnoœci),
\item[$r_i$] -- dane s¹ momenty przybycia zadañ,
\item[$no-wait$] -- przetwarzanie na maszynie II musi rozpocz¹æ siê natychmiast po zakoñczeniu przetwarzania na maszynie I,
\item[$C_{max}$] -- kryterium optymalizacyjne stanowi moment zakoñczenia przetwarzania ostatniego zadania (mo¿liwie jak najwczeœniej).
\end{description}

\subsection{Opis wejœcia}
Opis instancji problemu sprowadza siê do podania nastêpuj¹cych danych:
\begin{description}
\item[$n$] -- liczba szeregowanych zadañ,
	\begin{description}
	\item[$r'_i$] -- czas przybycia zadania,
	\item[$s'_i$] -- czas przygotowania na I maszynie,
	\item[$p'_i$] -- czas przetwarzania na I maszynie, 
	\item[$s''_i$] -- czas przygotowania II maszynie,
	\item[$p''_i$] -- czas przetwarzania na II maszynie (dla $i=1,2,\ldots,n$);
	\end{description}
\item[$m$] -- liczba okresów niedostêpnoœci,
	\begin{description}
	\item[$r_j$] -- czas rozpoczêcia okresu niedostêpnoœci,
	\item[$p_j$] -- d³ugoœæ okresu niedostêpnoœci dla ($j=1,2,\ldots,m$).
	\end{description}
\end{description}

Dziedzinê problemu stanowi¹ liczby ca³kowite nieujemne, tj. $n, m \in \mathbb{N}$ oraz $r_j, p_j, r_i, s'_i, s''_i, p''_i \in \mathbb{N}$ dla wszystkich dopuszczalnych wartoœci $i$ oraz $j$.

\newpage

Dodatkowo problem zosta³ ograniczony ze wzglêdu na wartoœci wystêpuj¹ce w instancji, które musz¹ spe³niaæ nastêpuj¹ce warunki:
\begin{itemize}
\item dla ka¿dego zadania czasy przetwarzania na obu maszynach zawieraj¹ siê w przedziale $\left[ 1, 100\right]$ jednostek, czyli:
\begin{displaymath}
\forall i=1,2,\ldots,n:
1 \leq p'_i \leq 100
\wedge
1 \leq p''_i \leq 100
\end{displaymath}

\item dla ka¿dego zadania czas przygotowania na danej maszynie nie przekracza 50\% czasu przetwarzania na tej maszynie, czyli:
\begin{displaymath}
\forall i=1,2,\ldots,n:
1 \leq s'_i \leq 50\%\; p'_i
\wedge
1 \leq s''_i \leq 50\%\; p''_i
\end{displaymath}

\item czasy trwania wszystkich okresów niedostêpnoœci zawieraj¹ siê w przedziale  $\left[ 1, 100\right]$ jednostek, czyli:
\begin{displaymath}
\forall j=1,2,\ldots,m:
1 \leq p_j \leq 100
\end{displaymath}
\end{itemize}

oraz ze wzglêdu na sumaryczne czasy przestojów i przetwarzania:
$$\sum_{j=1}^m p_j \leq 20\%\, \sum_{i=1}^n (s'_i + p'_i)$$

W dalszych rozwa¿aniach wygodniejsze bêdzie pos³ugiwanie siê jedynie wartoœciami $n$ i $m$, dlatego powy¿sza zale¿noœæ zostanie odpowiednio przekszta³cona z wykorzystaniem teorii prawdopodobieñstwa tak, aby uwzglêdnia³a losow¹ naturê generowanych testów.

Niech zmienna losowa $X$ odpowiada czasowi przetwarzania na I maszynie, zmienna losowa $Y$ czasowi przygotowania na II maszynie, a zmienna $Z$ d³ugoœci okresu niedostêpnoœci. 

Zmienna $X$ przyjmuje wartoœci $x_i$ dla $i=1,2,3,\ldots,99$, gdzie $x_i$ odpowiada czasowi przetwarzania równemu $i+1$ jednostek czasu. Rozk³ad zmiennej $X$ jest równomierny, zatem:
$$ \textrm{P}(X=x_i) = \frac{1}{99}$$

Wartoœæ œredni¹ zmiennej $X$ mo¿na obliczyæ wg wzoru:
$$ \textrm{E}(X) = \sum _{i=1} ^{99} x_i p(x_i) = 51$$

Zmienna $Y$ przyjmuje wartoœci $y_k$ dla $k=1,2,3,\ldots,50$, gdzie $y_k$ odpowiada czasowi przetwarzania równemu $k$ jednostek czasu. Rozk³ad zmiennej $Y$ jest równomierny, zatem:

\begin{displaymath}
\textrm{P}(Y=y_k | X=x_i) = \left\{ \begin{array}{ll}
\frac{1}{(i+1)/2} & k \leq (i+1)/2\\
0 & k>(i+1)/2
\end{array} \right.
\end{displaymath}

Wartoœæ œredni¹ zmiennej $Y$ mo¿na obliczyæ korzystaj¹c z nastêpuj¹cych zale¿noœci:

\begin{displaymath}
\textrm{E}(Y|X) = \int _{-\infty }^{\infty } y\; \textrm{d} F(y|x)= \sum _{k=1} ^{50} \textrm{p}({y_k}|{x_i})
\end{displaymath}

\begin{displaymath}
\textrm{E}(Y) = \int _{-\infty }^{\infty } \textrm{E}(Y|X)\; \textrm{d} F_1(x) = \sum _{i=1} ^{99} \textrm{E}(Y|X=x_i) \textrm{p}(x_i)
\end{displaymath}

Koñcowy wzór ma postaæ:
\begin{displaymath}
\textrm{E}(Y) = \sum _{i=1} ^{99} \sum _{k=1} ^{50} \textrm{p}({y_k}|{x_i}) \textrm{p}(x_i) = 13{,}13
\end{displaymath}

Zmienna $Z$ przyjmuje wartoœci $Z_i$ dla $i=1,2,3,\ldots,100$, gdzie $z_i$ odpowiada czasowi niedostêpnoœci równemu $i$ jednostek czasu. Rozk³ad zmiennej $Z$ jest równomierny, zatem:
$$ \textrm{P}(Z=z_i) = \frac{1}{100}$$

Wartoœæ œredni¹ zmiennej $Z$ mo¿na obliczyæ wg wzoru:
$$ \textrm{E}(Z) = \sum _{i=1} ^{100} z_i p(z_i) = 50{,}5$$

Z wartoœci œrednich zmiennych losowych $X$, $Y$, $Z$  mo¿na wyznaczyæ oczekiwany stosunek liczby zadañ do liczby okresów niedostêpnoœci tak aby spe³nione by³y warunki zadania:
$$m \textrm{E}(Z) \leq 20\%\, n (\textrm{E}(X)+\textrm{E}(Y))$$

Po przekszta³ceniu i podstawieniu wartoœci:
$$m \leq \SI{25.4}{\%} n$$

\subsection{Opis wyjœcia}
Dla danej instancji problemu rozwi¹zanie stanowi $n$ opisów uszeregowañ zadañ, z których ka¿dy jest zestawem nastêpuj¹cych liczb:
\begin{description}
	\item[$l'_i$] -- iloœæ okresów przetwarzania i-tego zadania na I maszynie,
		\begin{description}
		\item[$r'_{ik}$] -- czas rozpoczêcia j-tego okresu przetwarzania i-tego zadania,
		\item[$p'_{ik}$] -- d³ugoœæ j-tego okresu przetwarzania i-tego zadania (dla $k=1,2,\ldots,l'_i$);
		\end{description}
	\item[$r''_i$] -- czas rozpoczêcia przetwarzania i-tego zadania na II maszynie (dla $i=1,2,\ldots,n$).
\end{description}

W dalszych rozwa¿aniach przyjêto, ¿e okresy przetwarzania na I maszynie s¹ w obrêbie danego zadania posortowane chronologicznie, tj. zgodnie z rosn¹c¹ wartoœci¹ $r'_{ik}$:
$$\forall i=1,2,\ldots,n: \forall j=1,2,\ldots,l'_i-1: r'_{ij} < r''_{i(j+1)}$$

Przy tak przyjêtym opisie rozwi¹zania zachodzi równoœæ:
$$C_{max} = \max_{i=1}^n r''_i + p''_i$$

Zgodnie z postawionym problemem liczby wymienione powy¿ej musz¹ spe³niaæ nastêpuj¹ce warunki:
\begin{itemize}
\item przetwarzanie ka¿dego z zadañ rozpoczyna siê najwczeœniej w momencie jego przybycia, czyli:
$$\forall i=1,2,\ldots,n: p'_{i1} \geq r'_i$$

\item dla ka¿dego zadania sumaryczna d³ugoœæ okresów pracy zaplanowanych na I maszynie musi byæ równa czasowi zadanemu w instancji, czyli:
$$\forall i=1,2,\ldots,n: \sum_{k=1}^{l'_i} p'_{ik} = p'_i$$

\item dla ka¿dego zadania przetwarzanie na maszynie II musi rozpocz¹æ siê natychmiast po zakoñczeniu przetwarzania na maszynie I, czyli:
$$\forall i=1,2,\ldots,n: r'_{il'_i} + p'_{il'_i} = r''_i$$

\item niemo¿liwe jest przetwarzanie zadania podczas okresu niedostêpnoœci oraz jednoczesne przetwarzanie wiêcej ni¿ jednej czêœci tego samego zadania lub ró¿nych zadañ, innymi s³owy dla zbioru okresów przetwarzania:
$$A=\left\{ (i, j): i=0,1,\ldots,n \wedge j=1,2,\ldots,l'_i \right\}$$

gdzie jako zadanie o numerze $i=0$ przyjmujemy dodatkowe zadanie o okresach przetwarzania pokrywaj¹cych siê z okresami niedostêpnoœci, czyli:
\begin{eqnarray*}
& s'_0 = 0 \\
& l'_0 = m \\
& \forall j=1,2,\ldots,m: r'_{ij} = r_j \wedge  p'_{ij} = p_j
\end{eqnarray*}

okresy zawarte w zbiorze A odpowiadaj¹ parami roz³¹cznym przedzia³om czasu, czyli:
\begin{eqnarray*}
& \forall (i_1, j_1), (i_2, j_2) \in A, (i_1, j_1) \neq (i_2, j_2): \\
& [ r'_{i_1j_1} - s'_{i_1j_1}, r'_{i_1j_1} +p '_{i_1j_1} )
\cap
[ r'_{i_2j_2} - s'_{i_2j_2}, r'_{i_2j_2} +p '_{i_2j_2} )
=
\emptyset
\end{eqnarray*}

\item dla okreœlonej kolejnoœci zadañ przetwarzanie ka¿dego z nich zaczyna siê w pierwszej mo¿liwej chwili czasu, tj. nie wystêpuj¹ opóŸnienia inne, ni¿ wynikaj¹ce z opisanych wy¿ej warunków.
\end{itemize}

Wszystkie z powy¿szych warunków by³y automatycznie sprawdzane dla ka¿dego rozwi¹zania wygenerowanego w fazie testów poprawnoœciowych projektu.

\section{Opis algorytmu}
\subsection{Algorytm si³owy}
Si³owe rozwi¹zanie postawionego problemu wymaga sprawdzenia wartoœci kryterium $C_{max}$ dla wszystkich mo¿liwych kolejnoœci wykonania zadañ, czyli wszystkich permutacji $n$-elementowego ci¹gu, co daje algorytm o z³o¿onoœci rzêdu $O(n!)$. W obrêbie danej kolejnoœci zadañ rozpatrywane jest jedynie uszeregowanie o najmniejszej wartoœci $C_{max}$.
Algorytm typu \emph{brute force} zosta³ zaimplementowany jako pierwszy, jako narzêdzie umo¿liwiaj¹ce sprawdzenie poprawnoœci algorytmu obliczaj¹cego wartoœæ $C_{max}$. W praktyce algorytm taki ma rozs¹dny czas dzia³ania dla instancji o liczbie zadañ $n \leq 10$, dlatego w dalszych rozwa¿aniach zostanie on pominiêty.
W implementacji algorytmu si³owego wydzielona zosta³a czêœæ odpowiedzialna za obliczanie wartoœci $C_{max}$, w celu jej póŸniejszego wykorzystania w algorytmie aproksymacyjnym. Obliczenie wspomnianego parametru wymaga wyznaczenia momentu zakoñczenia ka¿dego z $n$ zadañ, co z kolei wymaga wyszukania wœród $m$ okresów niedostêpnoœci tych, które przerywaj¹ wykonywanie zadania. Poniewa¿ implementacja algorytmu wykorzystuje liniowo uporz¹dkowane struktury tablicowe do przechowywania opisów zarówno zadañ jak i okresów niedostêpnoœci, jej z³o¿onoœæ obliczeniowa jest rzêdu $O(n+m)$. Przy za³o¿eniu, ¿e $m \leq \SI{25,4}{\%} n$, z³o¿onoœæ jest rzêdu $O(n)$.
\subsection{Algorytm aproksymacyjny}
\subsubsection{Idea algorytmu}
Do rozwi¹zania postawionego problemu wykorzystany zosta³ schemat algorytmu typu \emph{tabu search}. Ogólna idea tego algorytmu polega na iteracyjnym poprawianiu pewnego rozwi¹zania, ustalonego na pocz¹tku dzia³ania algorytmu. Rozwi¹zanie to mo¿e byæ wylosowane, oszacowane przy pomocy algorytmu zach³annego lub wyliczone jako pierwsze (w sensie np. leksykograficznym) dozwolone w warunkach zadania, przy czym, im bli¿sze jest ono rozwi¹zaniu optymalnemu, tym szybciej i z lepszymi efektem zakoñczy siê dzia³anie algorytmu. Proces poprawiania rozwi¹zania polega na sekwencyjnym wykonywaniu na nim pewnej operacji, zwanej krokiem elementarnym, która prowadzi do innego rozwi¹zania. Zbiór wszystkich rozwi¹zañ, które mo¿na otrzymaæ przez wykonanie dowolnego z mo¿liwych kroków elementarnym nazywane jest s¹siedztwem rozwi¹zania. Krokiem wykonywanym w danej iteracji jest ten, spoœród mo¿liwych, który prowadzi do rozwi¹zania najlepszego w aktualnym s¹siedztwie. Po wykonaniu operacji jest ona umieszczana na liœcie kroków zabronionych, zwanej list¹ tabu, co ma na celu wykluczenie sytuacji, w której algorytm zapêtli siê, wykonuj¹c naprzemiennie te same kroki. Krok znajduj¹cy siê na liœcie tabu mo¿e zostaæ wykonany jedynie wtedy, kiedy spe³nia pewien dodatkowy warunek, zwany kryterium aspiracji. Warunek stopu okreœla siê w implementacji algorytmu.

\subsubsection{Implementacja algorytmu}
Program rozwi¹zuj¹cy postawiony problem zosta³ podzielony na dwie czêœci: procedury obliczaj¹ce optymalny sposób przetwarzania zadañ dla pewnej ustalonej ich kolejnoœci (permutacji) oraz czêœæ zwi¹zan¹ z poszukiwaniem tej kolejnoœci, dla której wartoœæ $C_{max}$ bêdzie jak najmniejsza. W ramach pierwszej czêœci wykorzystany zosta³ algorytm opracowany na potrzeby rozwi¹zania si³owego, druga zosta³a zaimplementowana z wykorzystaniem idei algorytmu \emph{tabu search}, którego elementy sprecyzowano w opisany ni¿ej sposób.

\paragraph{Krok elementarny}
W fazie doœwiadczalnej projektu testowane by³y algorytmy korzystaj¹ce z trzech ró¿nie zdefiniowanych kroków elementarnych. Wersje te, zwane dalej \emph{MoveIndex}, \emph{SwapIndex} i \emph{SwapTask}, operuj¹ na permutacji wyznaczaj¹cej kolejnoœæ przetwarzania zadañ i realizuj¹ krok elementarny opisany par¹ liczb $(a, b)$ w nastêpuj¹cy sposób:
\begin{description}
\item[\emph{MoveIndex}] -- przemieszczenia zadania z pozycji $a$ na pozycjê $b$,
\item[\emph{SwapIndex}] -- zamiana miejscami zadañ na pozycjach $a$ i $b$,
\item[\emph{SwapTask}] -- zamiana miejscami zadañ o numerach $a$ i $b$.
\end{description}
Sprawdzenie ka¿dego z kroków wymaga obliczenia wartoœci $C_{max}$ dla powsta³ej permutacji zadañ, czyli wykonania - zgodnie z wczeœniejszymi ustaleniami - $O(n)$ operacji. Iloœci mo¿liwych kroków oraz wynikaj¹c¹ z nich z³o¿onoœæ obliczeniow¹ algorytmu dla poszczególnych wersji przedstawia tabela.

\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|}
\hline
Metoda & Iloœæ kroków & Z³o¿onoœæ \\
\hline
MoveIndex & $(n-1)^2$ & $O(n^3)$ \\
SwapIndex & $\frac{n (n-1)}{2}$ & $O(n^3)$ \\
SwapTask & $\frac{n (n-1)}{2}$ & $O(n^3)$ \\
\hline
\end{tabular}
\end{table}

\paragraph{Lista tabu}
Wykonanie kroku elementarnego wi¹¿e siê z jego umieszczeniem na liœcie tabu. Aby umo¿liwiæ szybkie sprawdzanie dostêpnoœci kroków, ich opisy s¹ przechowywane w drzewie binarnym. W fazie doœwiadczalnej projektu testowane by³y dwie koncepcje listy tabu, zwane dalej \emph{DoubleBlock} i \emph{MultiBlock}, które dla kroku opisanego przez parê liczb $(a, b)$ powoduj¹ zablokowanie:
\begin{description}
\item[\emph{DoubleBlock}] -- danego kroku i kroku odwrotnego, tj. kroków $(a, b)$ i $(b, a)$,
\item[\emph{MultiBlock}] -- wszystkich kroków zawieraj¹cych w opisie liczby $a$ i $b$, czyli takich kroków $(x, y)$ i $(y, x)$, ¿e $x \neq y$ i $x \in \{a, b\}$, a $y$ jest dowoln¹ liczb¹ tworz¹c¹ razem z $x$ prawid³owy krok.
\end{description}
D³ugoœæ listy tabu jest parametrem algorytmu (zwanym dalej \emph{tabus}). W szczególnoœci, dla d³ugoœci równej 0, implementacja staje siê realizacj¹ algorytmu \emph{local search}.

\paragraph{Warunek stopu}
Iteracje algorytmu wykonywane s¹ bezwarunkowo dopóty, dopóki poprawia siê wartoœæ $C_{max}$. Nastêpnie wykonywana jest pewna iloœæ dodatkowych iteracji, w trakcie których mo¿liwa jest dalsza zmiana s¹siedztwa rozwi¹zania, a¿ do ewentualnego znalezienia obszaru o lepszej wartoœci $C_{max}$. W przypadku nie znalezienia takiego obszaru algorytm koñczy siê. Iloœæ dodatkowych iteracji jest parametrem algorytmu (zwanym dalej \emph{chances}).

\paragraph{Kryterium aspiracji}


\subsubsection{Usprawnienia algorytmu}
\paragraph{Ograniczenie liczby ruchów}
W celu ograniczenia z³o¿onoœci algorytmu wprowadzony zosta³ dodatkowy parametr, zwany dalej \emph{distance}. Mówi on, jaka mo¿e byæ maksymalna odleg³oœæ w permutacji pomiêdzy zadaniem, a miejscem w które zostanie przesuniête w kroku elementarnym. W szczególnoœci, dla odleg³oœci równej 1, rozwa¿ane s¹ jedynie s¹siednie zadania, co daje z³o¿onoœæ algorytmu rzêdu $O(n^2)$.

\paragraph{Zach³anna inicjalizacja}
W pierwszej implementacji pocz¹tkowa permutacja by³a losowana. Metoda ta nie sprawdza siê jednak przy niezerowych czasach przybycia, gdy¿ prowadzi do rozwi¹zañ dalekich od optymalnych. Znacznie lepsze efekty przynosi wstêpne posortowanie zadañ rosn¹co wed³ug ich momentów przybycia, czyli rozwa¿anie pewnego ,,naturalnego'', chronologicznego porz¹dku zadañ.

Dalsze usprawnienie algorytmu mo¿liwe jest dziêki wstêpnemu ustawieniu zadañ w sposób zach³anny, tj. kolejno wybieraj¹c zadania, które w danym momencie prowadz¹ do najkrótszego uszeregowania.

\section{Wyniki eksperymentu}
Faza doœwiadczalna opiera³a siê na serii zautomatyzowanych testów wykonanych na losowo generowanych instancjach. Pomiary wykonywano w œrodowisku GNU/Linux przy pomocy kompilatora GCC w wersji 4.1.2 na komputerach z procesorami AMD Athlon XP \SI{1.8}{GHz} i Intel Celeron M \SI{1.4}{GHz}. Podczas analizy pomiary wykonane na ró¿nych komputerach nie by³y wzajemnie porównywane.


\subsection{Wybór implementacji}
Pierwszym eksperymentu by³ wybór najlepszej z opracowanych wersji algorytmu. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{impl}
\end{figure}

\subsubsection{(przyk³ad na ma³ej instancji)}
\subsubsection{(bad case)}

\subsection{Optymalizacja parametrów}
\subsubsection{Wp³yw parametrów na czas obliczeñ}
Przed przyst¹pieniem do optymalizacji parametrów algorytmu konieczne by³o sprawdzenie jaki wp³yw maj¹ one na czas trwania obliczeñ, aby w dalszym toku eksperymentu preferowaæ takie zmiany parametrów, które powoduj¹ mo¿liwie najmniejsze opóŸnienia w otrzymywaniu wyników.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{time-tabus}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{time-chances}
\end{figure}

\subsubsection{Wp³yw parametrów na jakoœæ rozwi¹zania}
\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{cmax-tabus-50}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{cmax-tabus-75}
\end{figure}

chances(step6)
distance(sta³e chances)

\subsection{Testy wydajnoœæiowe}

\end{document}

